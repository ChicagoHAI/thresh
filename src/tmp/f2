process_simplified_html_with_selected_span(category) {
            let start = this.selected_span_in_simplified_indexs[0]
            let end = this.selected_span_in_simplified_indexs[1]
            let prev_idx = 0
            let sentence_html = ''
            let simplified_sentence = this.hits_data[this.current_hit - 1].simplified
            let simplified_spans = JSON.parse(JSON.stringify(this.hits_data[this.current_hit - 1].simplified_spans))
            let category_id = this.category_to_id[category]
            if (this.enable_multi_select_simplified_sentence) {
                for (let i = 0; i < this.selected_span_in_simplified_indexs.length; i++) {
                    simplified_spans.push([category_id, this.selected_span_in_simplified_indexs[i][0], this.selected_span_in_simplified_indexs[i][1]])
                }
            } else {
                simplified_spans.push([category_id, start, end]);
            }
            // rank simplified_spans list by [1]
            simplified_spans.sort(function(a, b) {
                return a[1] - b[1] || b[2] - a[2];
            });
            // iterate simplified_spans list
            for (let i = 0; i < simplified_spans.length; i++) {
                sentence_html += simplified_sentence.substring(prev_idx, simplified_spans[i][1]);
                let span_category = this.id_to_category[simplified_spans[i][0]]
                let outside = ""
                if (i < simplified_spans.length - 1 && simplified_spans[i + 1][1] <= simplified_spans[i][2]) {
                    outside = "outside"
                }
                let whether_is_selected = false
                if (this.enable_multi_select_simplified_sentence) {
                    for (let j = 0; j < this.selected_span_in_simplified_indexs.length; j++) {
                        if (simplified_spans[i][1] == this.selected_span_in_simplified_indexs[j][0] && simplified_spans[i][2] == this.selected_span_in_simplified_indexs[j][1] && span_category == category) {
                            whether_is_selected = true
                            break
                        }
                    }
                } else {
                    if (simplified_spans[i][1] == start && simplified_spans[i][2] == end && span_category == category) {
                        whether_is_selected = true
                    }
                }
                if (whether_is_selected) {
                    sentence_html += `<span @mouseover.stop @mouseout.stop class="bg-${span_category}-light span ${outside}">`;
                } else {
                    if (span_category == "split" && (simplified_sentence.substring(simplified_spans[i][1], simplified_spans[i][2]) =="||")) {
                        sentence_html += `<span @mousedown.stop @mouseup.stop @click="click_span"  @mouseover="hover_span" @mouseout="un_hover_span" class="${span_category} pointer span simplified_span txt-split split-sign ${outside}" data-category="${span_category}" data-id="${span_category}-` + simplified_spans[i][3] + `">`;
                    } else {
                        sentence_html += `<span @mousedown.stop @mouseup.stop @click="click_span" @mouseover="hover_span" @mouseout="un_hover_span" class="${span_category} border-${span_category} pointer span simplified_span ${outside}" data-category="${span_category}" data-id="${span_category}-` + simplified_spans[i][3] + `">`;
                    }
                }
                let start_i = i
                let whether_more_overlap = false
                while (i < simplified_spans.length - 1 && simplified_spans[i + 1][1] <= simplified_spans[start_i][2]) {
                    // the next span is in the current span
                    let next_span = simplified_spans[i + 1]
                    if (i == start_i) {
                        sentence_html += simplified_sentence.substring(simplified_spans[i][1], next_span[1]);
                    } else {
                        if (whether_more_overlap) {
                            sentence_html += simplified_sentence.substring(simplified_spans[i - 1][2], next_span[1]);
                        } else {
                            sentence_html += simplified_sentence.substring(simplified_spans[i][2], next_span[1]);
                        }
                    }                  
                    whether_more_overlap = false  
                    let next_category = this.id_to_category[next_span[0]]
                    let outside = ""
                    if (i < simplified_spans.length - 2 && simplified_spans[i + 2][1] <= simplified_spans[i+1][2]) {
                        outside = "middleside"
                    }

                    whether_is_selected = false
                    if (this.enable_multi_select_simplified_sentence) {
                        for (let j = 0; j < this.selected_span_in_simplified_indexs.length; j++) {
                            if (next_span[1] == this.selected_span_in_simplified_indexs[j][0] && next_span[2] == this.selected_span_in_simplified_indexs[j][1] && next_category == category) {
                                whether_is_selected = true
                                break
                            }
                        }
                    } else {
                        if (next_span[1] == start && next_span[2] == end && next_category == category) {
                            whether_is_selected = true
                        }
                    }
                    if (whether_is_selected) {
                        sentence_html += `<span @mouseover.stop @mouseout.stop class="bg-${next_category}-light span ${outside}">`;
                    } else {
                        if (next_category == "split" && (simplified_sentence.substring(next_span[1], next_span[2]) =="||")) {
                            sentence_html += `<span @mouseover.stop @mouseout.stop @click.stop @click="click_span"  @mouseover="hover_span" @mouseout="un_hover_span" class="${next_category} pointer span simplified_span txt-split split-sign" data-category="${next_category}" data-id="${next_category}-` + next_span[3] + `">`;
                        } else {
                            let light = "-light"
                            let simplified_span_id = next_span[3]
                            if (("annotations" in this.hits_data[[this.current_hit - 1]]) && (simplified_span_id in this.hits_data[[this.current_hit - 1]].annotations[next_category])) {
                                light = ""
                            }
                            sentence_html += `<span @mouseover.stop @mouseout.stop @click.stop @click="click_span" @mouseover="hover_span" @mouseout="un_hover_span" class="${next_category} border-${next_category}${light} pointer span simplified_span ${outside}" data-category="${next_category}" data-id="${next_category}-` + next_span[3] + `">`;
                        }
                    }
                    i++;
                    if (i < simplified_spans.length - 1 && simplified_spans[i + 1][1] <= simplified_spans[i][2]) {
                        whether_more_overlap = true
                        // the next span is in the current span
                        let next_next_span = simplified_spans[i + 1]
                        sentence_html += simplified_sentence.substring(simplified_spans[i][1], next_next_span[1]);  
                        let next_category = this.id_to_category[next_next_span[0]]

                        whether_is_selected = false
                        if (this.enable_multi_select_simplified_sentence) {
                            for (let j = 0; j < this.selected_span_in_simplified_indexs.length; j++) {
                                if (next_next_span[1] == this.selected_span_in_simplified_indexs[j][0] && next_next_span[2] == this.selected_span_in_simplified_indexs[j][1] && next_category == category) {
                                    whether_is_selected = true
                                    break
                                }
                            }
                        } else {
                            if (next_next_span[1] == start && next_next_span[2] == end && next_category == category) {
                                whether_is_selected = true
                            }
                        }
                        if (whether_is_selected) {
                            sentence_html += `<span @mouseover.stop @mouseout.stop class="bg-${next_category}-light span">`;
                        } else {
                            if (next_category == "split" && (simplified_sentence.substring(next_next_span[1], next_next_span[2]) =="||")) {
                                sentence_html += `<span @mouseover.stop @mouseout.stop @click.stop @click="click_span"  @mouseover="hover_span" @mouseout="un_hover_span" class="${next_category} pointer span simplified_span txt-split split-sign" data-category="${next_category}" data-id="${next_category}-` + next_next_span[3] + `">`;
                            } else {
                                let light = "-light"
                                let simplified_span_id = next_next_span[3]
                                if (("annotations" in this.hits_data[[this.current_hit - 1]]) && (simplified_span_id in this.hits_data[[this.current_hit - 1]].annotations[next_category])) {
                                    light = ""
                                }
                                sentence_html += `<span @mouseover.stop @mouseout.stop @click.stop @click="click_span" @mouseover="hover_span" @mouseout="un_hover_span" class="${next_category} border-${next_category}${light} pointer span simplified_span" data-category="${next_category}" data-id="${next_category}-` + next_next_span[3] + `">`;
                            }
                        }
                        sentence_html += simplified_sentence.substring(next_next_span[1], next_next_span[2]);
                        sentence_html += "</span>";
                        sentence_html += simplified_sentence.substring(next_next_span[2], simplified_spans[i][2]);
                        // console.log(simplified_sentence.substring(next_next_span[2], simplified_spans[i][2]))
                        sentence_html += `</span>`;
                        i++;
                    } else {
                        sentence_html += simplified_sentence.substring(next_span[1], next_span[2]);
                        sentence_html += "</span>";
                    }
                }
                if (start_i != i) {
                    if (whether_more_overlap) {
                        sentence_html += simplified_sentence.substring(simplified_spans[i - 1][2], simplified_spans[start_i][2]);
                    } else {
                        sentence_html += simplified_sentence.substring(simplified_spans[i][2], simplified_spans[start_i][2]);
                    }
                    sentence_html += `</span>`;
                    prev_idx = simplified_spans[start_i][2];
                } else {
                    sentence_html += simplified_sentence.substring(simplified_spans[i][1], simplified_spans[i][2]);
                    sentence_html += `</span>`;
                    prev_idx = simplified_spans[i][2];
                }
            }
            sentence_html += simplified_sentence.substring(prev_idx);
            this.simplified_html = sentence_html;
        },